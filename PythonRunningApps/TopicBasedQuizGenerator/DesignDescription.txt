- Create a new widget for DS, ML, AI, DE, DM and more in Tkinter.
  - Pick a topic, ask questions, reveal answer.
    - Correct Option : Wrong/Correct
    - User wont need to type in an answer just pick worng or correct
  - Pick number of Questions for that topic
     - Add a progress bar on the bottom when the quiz starts
  - How many was correct out of 10
     - Keep track of this in a Database (SSMS)
  - Keep a flag (Red, Yellow and Green)
     - Red : Wrong Answer previously
     - Amber : Wasn't correct 5 times in a row
     - Green : Got it right 5 times in a row
  - Keep track of how many questions were shown from the total
     - Add a progress bar on the bottom in Home page of this
  - Keep track of how fast you answered each question (new time for each question)
     - Only store if it's new Record and show new record on screen in green
  - Another page for analytics and charts
    - Number of total question from all topics
    - Number of total question for specific topic
    - Wrong/Correct Ratio from all topics
    - Wrong/Correct Ratio for each topic
    - How many questions were answered each day
    - Wrong/Correct Ratio each day for all topics
    - Highest Correct answer streak
    - Visualize streak trends over time.
    - Visualize scores trends over time for 5 question quiz
    - Visualize scores trends over time for 10 question quiz 
    - Visualize scores trends over time for 15 question quiz
    - Visualize scores trends over time for 50 question quiz
  - Add Favourite star option for each question
    - Function to also choose favourited questions only
 - Make you you capture datetime of each question and when it was last seen
    - If the question has not been seen for over a month then mark that as LTNS
       - LTNS questions should be grouped as LSTN topic.
 - Add another page for Rewards and achievement
    - First 10 Correct Anseers in a Row
    - First 100  Correct Anseers in a Row
    - Reached 70% Correct/Wrong Ratio for specifc topics
    - Reached 80% Correct/Wrong Ratio for specifc topics
    - Reached 90% Correct/Wrong Ratio for specifc topics
    - Reached 70% Correct/Wrong Ratio for all topics
    - Reached 80% Correct/Wrong Ratio for all topics
    - Reached 90% Correct/Wrong Ratio for all topics
    - All Qestions correct in a 5  question quiz
    - All Qestions correct in a 10 question quiz
    - All Qestions correct in a 15 question quiz
    - All Qestions correct in a 50 question quiz
- Quiz History and Review
   - Let users review their past quizzes and scores
- Dynamic Quiz Modes
  - Allow user to build their own Quiz based on keywords, sub-topics for the question
  - Allow user to choose top 10 questions that were answered incorrectly the most
  - Survival Mode: Introduce a survival quiz mode where users must answer questions correctly to continue. 
                             The quiz ends when a user gets a certain number of questions wrong, 
                             Highest Streak of this should be captured in Analytics.


erDiagram
    USER {
        int user_id PK
        string username
        string email
        datetime created_at
        int current_streak
        int highest_streak
        datetime last_streak_date
    }
    TOPIC {
        int topic_id PK
        string topic_name
    }
    QUESTION {
        int question_id PK
        int topic_id FK
        string question_text
        string correct_answer
        string keywords
        string subtopics
        boolean is_favorite
        datetime last_seen
        boolean is_ltns
        int difficulty_level
        int incorrect_count
        string flag
    }
    QUIZ_SESSION {
        int session_id PK
        int user_id FK
        int topic_id FK
        datetime start_time
        datetime end_time
        int total_questions
        int correct_answers
        string quiz_type
        int session_streak
    }
    USER_ANSWER {
        int answer_id PK
        int session_id FK
        int question_id FK
        boolean is_correct
        float answer_time
        datetime answered_at
    }
    ACHIEVEMENT {
        int achievement_id PK
        string achievement_name
        string description
        int threshold
    }
    USER_ACHIEVEMENT {
        int user_id FK
        int achievement_id FK
        datetime achieved_at
    }
    USER_TOPIC_STATS {
        int stat_id PK
        int user_id FK
        int topic_id FK
        int total_questions
        int total_answered
        int total_correct
        float progress_percentage
        int highest_streak
        float avg_answer_time
        datetime last_quiz_date
    }
    QUESTION_HISTORY {
        int history_id PK
        int question_id FK
        int user_id FK
        datetime viewed_at
        boolean was_correct
        float answer_time
    }
    USER_QUESTION_STREAK {
        int streak_id PK
        int user_id FK
        int question_id FK
        int current_correct_streak
        int current_incorrect_streak
        int max_correct_streak
        int max_incorrect_streak
        datetime last_answered
    }

    USER ||--o{ QUIZ_SESSION : "participates in"
    USER ||--o{ USER_ACHIEVEMENT : "earns"
    USER ||--o{ USER_TOPIC_STATS : "has"
    USER ||--o{ QUESTION_HISTORY : "tracks"
    USER ||--o{ USER_QUESTION_STREAK : "has"
    USER ||--o{ QUIZ_SESSION : "participates in"
    TOPIC ||--o{ QUESTION : "contains"
    TOPIC ||--o{ USER_TOPIC_STATS : "tracked in"
    TOPIC ||--o{ QUIZ_SESSION : "belongs to"
    QUIZ_SESSION ||--|{ USER_ANSWER : "includes"
    QUIZ_SESSION ||--|{ USER_ANSWER : "includes"
    QUESTION ||--o{ USER_ANSWER : "answered in"
    QUESTION ||--o{ QUESTION_HISTORY : "recorded in"
    QUESTION ||--o{ USER_QUESTION_STREAK : "tracked in"
    QUESTION ||--o{ USER_ANSWER : "answered in"
    ACHIEVEMENT ||--o{ USER_ACHIEVEMENT : "earned by"

Show me this ER diagram and state what it might be trying to achieve


Improve the accuracy and clarity of this description and am I missing anything in the ERD as per the descrription without adding addional features and out of 10 what would you mark this ERD design as per description?


Complex analysis :

Learning Curve Analysis - This query calculates a moving average of user performance over their last 10 quiz sessions, allowing you to visualize their learning curve.

WITH user_performance AS (
  SELECT 
    u.user_id,
    qs.start_time,
    qs.correct_answers::float / qs.total_questions AS performance_ratio
  FROM USER u
  JOIN QUIZ_SESSION qs ON u.user_id = qs.user_id
  ORDER BY u.user_id, qs.start_time
)
SELECT 
  user_id,
  start_time,
  performance_ratio,
  AVG(performance_ratio) OVER (
    PARTITION BY user_id 
    ORDER BY start_time
    ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
  ) AS moving_average
FROM user_performance;

Topic Difficulty Analysis - You can analyze the relative difficulty of different topics based on user performance:

SELECT 
  t.topic_id,
  t.topic_name,
  AVG(qs.correct_answers::float / qs.total_questions) AS avg_performance,
  AVG(ua.answer_time) AS avg_answer_time
FROM TOPIC t
JOIN QUIZ_SESSION qs ON t.topic_id = qs.topic_id
JOIN USER_ANSWER ua ON qs.session_id = ua.session_id
GROUP BY t.topic_id, t.topic_name
ORDER BY avg_performance ASC, avg_answer_time DESC;

User Engagement Patterns - You can analyze how user engagement correlates with performance:

WITH user_activity AS (
  SELECT 
    user_id,
    COUNT(DISTINCT DATE(start_time)) AS active_days,
    AVG(correct_answers::float / total_questions) AS avg_performance
  FROM QUIZ_SESSION
  GROUP BY user_id
)
SELECT 
  CASE 
    WHEN active_days < 10 THEN 'Low'
    WHEN active_days < 30 THEN 'Medium'
    ELSE 'High'
  END AS engagement_level,
  AVG(avg_performance) AS avg_performance
FROM user_activity
GROUP BY engagement_level;

Spaced Repetition Effectiveness - You can analyze how the spacing between question reviews affects performance:

WITH question_intervals AS (
  SELECT 
    user_id,
    question_id,
    viewed_at,
    LAG(viewed_at) OVER (PARTITION BY user_id, question_id ORDER BY viewed_at) AS prev_viewed_at,
    was_correct
  FROM QUESTION_HISTORY
)
SELECT 
  CASE 
    WHEN EXTRACT(DAY FROM (viewed_at - prev_viewed_at)) < 1 THEN 'Same day'
    WHEN EXTRACT(DAY FROM (viewed_at - prev_viewed_at)) < 7 THEN 'Within week'
    WHEN EXTRACT(DAY FROM (viewed_at - prev_viewed_at)) < 30 THEN 'Within month'
    ELSE 'Over a month'
  END AS review_interval,
  AVG(CASE WHEN was_correct THEN 1 ELSE 0 END) AS correct_ratio
FROM question_intervals
WHERE prev_viewed_at IS NOT NULL
GROUP BY review_interval;

Achievement Impact Analysis - You can analyze how achieving certain milestones affects user performance:

WITH user_performance AS (
  SELECT 
    ua.user_id,
    a.achievement_name,
    ua.achieved_at,
    qs.start_time,
    qs.correct_answers::float / qs.total_questions AS performance
  FROM USER_ACHIEVEMENT ua
  JOIN ACHIEVEMENT a ON ua.achievement_id = a.achievement_id
  JOIN QUIZ_SESSION qs ON ua.user_id = qs.user_id
)
SELECT 
  achievement_name,
  AVG(CASE WHEN start_time < achieved_at THEN performance END) AS avg_performance_before,
  AVG(CASE WHEN start_time >= achieved_at THEN performance END) AS avg_performance_after
FROM user_performance
GROUP BY achievement_name;

Question Difficulty Progression - You can analyze how the difficulty of questions changes over time for users:

WITH user_question_performance AS (
  SELECT 
    ua.user_id,
    q.question_id,
    q.difficulty_level,
    ua.is_correct,
    ROW_NUMBER() OVER (PARTITION BY ua.user_id, q.question_id ORDER BY ua.answered_at) AS attempt_number
  FROM USER_ANSWER ua
  JOIN QUESTION q ON ua.question_id = q.question_id
)
SELECT 
  difficulty_level,
  attempt_number,
  AVG(CASE WHEN is_correct THEN 1 ELSE 0 END) AS correct_ratio
FROM user_question_performance
WHERE attempt_number <= 5
GROUP BY difficulty_level, attempt_number
ORDER BY difficulty_level, attempt_number;


User Improvement Rate Analysis - This analysis calculates each user's rate of improvement over time, both as an average week-to-week change and as a linear trend.

WITH user_weekly_performance AS (
  SELECT 
    user_id,
    DATE_TRUNC('week', start_time) AS week,
    AVG(correct_answers::float / total_questions) AS weekly_performance
  FROM QUIZ_SESSION
  GROUP BY user_id, DATE_TRUNC('week', start_time)
),
user_improvement AS (
  SELECT 
    user_id,
    week,
    weekly_performance,
    LAG(weekly_performance) OVER (PARTITION BY user_id ORDER BY week) AS prev_week_performance,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY week) AS week_number
  FROM user_weekly_performance
)
SELECT 
  user_id,
  AVG(weekly_performance - prev_week_performance) AS avg_weekly_improvement,
  REGR_SLOPE(weekly_performance, week_number) AS improvement_trend
FROM user_improvement
WHERE prev_week_performance IS NOT NULL
GROUP BY user_id
ORDER BY improvement_trend DESC;

Concept Mastery Progression - This query tracks how many attempts it takes for a user to achieve "mastery" (defined here as a moving average of 80% correct over the last 5 attempts) for each subtopic.

WITH user_concept_performance AS (
  SELECT 
    ua.user_id,
    q.subtopics,
    ua.is_correct,
    ua.answered_at,
    ROW_NUMBER() OVER (PARTITION BY ua.user_id, q.subtopics ORDER BY ua.answered_at) AS attempt_number
  FROM USER_ANSWER ua
  JOIN QUESTION q ON ua.question_id = q.question_id
),
concept_mastery AS (
  SELECT 
    user_id,
    subtopics,
    attempt_number,
    AVG(CASE WHEN is_correct THEN 1 ELSE 0 END) OVER 
      (PARTITION BY user_id, subtopics ORDER BY attempt_number
       ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS moving_avg_correct
  FROM user_concept_performance
)
SELECT 
  user_id,
  subtopics,
  MIN(CASE WHEN moving_avg_correct >= 0.8 THEN attempt_number ELSE NULL END) AS attempts_to_mastery
FROM concept_mastery
GROUP BY user_id, subtopics
HAVING MIN(CASE WHEN moving_avg_correct >= 0.8 THEN attempt_number ELSE NULL END) IS NOT NULL
ORDER BY user_id, attempts_to_mastery;

Learning Curve Steepness - This query calculates the steepness of each user's learning curve, showing how quickly they're improving over time.

WITH user_daily_performance AS (
  SELECT 
    user_id,
    DATE(start_time) AS study_date,
    AVG(correct_answers::float / total_questions) AS daily_performance,
    ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY DATE(start_time)) AS day_number
  FROM QUIZ_SESSION
  GROUP BY user_id, DATE(start_time)
)
SELECT 
  user_id,
  REGR_SLOPE(daily_performance, day_number) AS learning_curve_steepness,
  REGR_R2(daily_performance, day_number) AS r_squared
FROM user_daily_performance
GROUP BY user_id
HAVING COUNT(*) >= 7  -- Only consider users with at least a week of data
ORDER BY learning_curve_steepness DESC;

Spaced Repetition Optimal Interval - This query determines the optimal interval for spaced repetition for each user, based on their performance at different intervals.

WITH question_intervals AS (
  SELECT 
    user_id,
    question_id,
    viewed_at,
    was_correct,
    LAG(viewed_at) OVER (PARTITION BY user_id, question_id ORDER BY viewed_at) AS prev_viewed_at
  FROM QUESTION_HISTORY
),
interval_performance AS (
  SELECT 
    user_id,
    EXTRACT(DAY FROM (viewed_at - prev_viewed_at)) AS days_since_last_view,
    AVG(CASE WHEN was_correct THEN 1 ELSE 0 END) AS correct_ratio
  FROM question_intervals
  WHERE prev_viewed_at IS NOT NULL
  GROUP BY user_id, EXTRACT(DAY FROM (viewed_at - prev_viewed_at))
)
SELECT 
  user_id,
  days_since_last_view AS optimal_interval,
  MAX(correct_ratio) AS best_performance
FROM interval_performance
GROUP BY user_id
ORDER BY best_performance DESC;

Learning Style Adaptation - This query identifies each user's preferred learning style (based on quiz type) and compares their performance in that style to others, showing how much they benefit from style-adapted learning.

WITH user_session_types AS (
  SELECT 
    user_id,
    quiz_type,
    AVG(correct_answers::float / total_questions) AS avg_performance,
    COUNT(*) AS session_count
  FROM QUIZ_SESSION
  GROUP BY user_id, quiz_type
),
user_preferred_style AS (
  SELECT 
    user_id,
    quiz_type AS preferred_style,
    avg_performance AS preferred_performance
  FROM user_session_types
  WHERE (user_id, avg_performance) IN (
    SELECT user_id, MAX(avg_performance)
    FROM user_session_types
    GROUP BY user_id
  )
)
SELECT 
  ups.user_id,
  ups.preferred_style,
  ups.preferred_performance,
  AVG(ust.avg_performance) AS avg_performance_other_styles,
  ups.preferred_performance - AVG(ust.avg_performance) AS performance_difference
FROM user_preferred_style ups
JOIN user_session_types ust ON ups.user_id = ust.user_id AND ups.preferred_style != ust.quiz_type
GROUP BY ups.user_id, ups.preferred_style, ups.preferred_performance
ORDER BY performance_difference DESC;

Knowledge Retention Analysis - This query analyzes how well users retain knowledge over different time periods, focusing on questions they previously answered correctly.

WITH question_attempts AS (
  SELECT 
    user_id,
    question_id,
    is_correct,
    answered_at,
    LAG(answered_at) OVER (PARTITION BY user_id, question_id ORDER BY answered_at) AS prev_attempt_date,
    LAG(is_correct) OVER (PARTITION BY user_id, question_id ORDER BY answered_at) AS prev_attempt_correct
  FROM USER_ANSWER
)
SELECT 
  CASE 
    WHEN EXTRACT(DAY FROM (answered_at - prev_attempt_date)) <= 1 THEN 'Same day'
    WHEN EXTRACT(DAY FROM (answered_at - prev_attempt_date)) <= 7 THEN 'Within week'
    WHEN EXTRACT(DAY FROM (answered_at - prev_attempt_date)) <= 30 THEN 'Within month'
    ELSE 'After month'
  END AS retention_period,
  AVG(CASE WHEN prev_attempt_correct AND is_correct THEN 1 
           WHEN prev_attempt_correct AND NOT is_correct THEN 0 
      END) AS retention_rate
FROM question_attempts
WHERE prev_attempt_date IS NOT NULL AND prev_attempt_correct = TRUE
GROUP BY retention_period
ORDER BY retention_rate DESC;

Difficulty Progression Impact - This query examines how the progression of question difficulty affects user performance over time, potentially revealing optimal challenge levels for each user.

WITH user_difficulty_progression AS (
  SELECT 
    qs.user_id,
    qs.session_id,
    qs.start_time,
    AVG(q.difficulty_level) AS avg_difficulty,
    qs.correct_answers::float / qs.total_questions AS performance,
    ROW_NUMBER() OVER (PARTITION BY qs.user_id ORDER BY qs.start_time) AS session_number
  FROM QUIZ_SESSION qs
  JOIN USER_ANSWER ua ON qs.session_id = ua.session_id
  JOIN QUESTION q ON ua.question_id = q.question_id
  GROUP BY qs.user_id, qs.session_id, qs.start_time, qs.correct_answers, qs.total_questions
)
SELECT 
  user_id,
  CORR(avg_difficulty, performance) AS difficulty_performance_correlation,
  REGR_SLOPE(avg_difficulty, session_number) AS difficulty_progression_rate,
  REGR_SLOPE(performance, session_number) AS performance_improvement_rate
FROM user_difficulty_progression
GROUP BY user_id
HAVING COUNT(*) >= 10  -- Only consider users with at least 10 sessions
ORDER BY performance_improvement_rate DESC;


Learning Plateau Detection - This query detects learning plateaus, where a user's performance stabilizes over time, which could indicate a need for new challenges or learning strategies.

WITH user_performance_trend AS (
  SELECT 
    user_id,
    start_time,
    correct_answers::float / total_questions AS performance,
    AVG(correct_answers::float / total_questions) OVER (
      PARTITION BY user_id 
      ORDER BY start_time 
      ROWS BETWEEN 9 PRECEDING AND CURRENT ROW
    ) AS moving_avg_performance
  FROM QUIZ_SESSION
),
plateau_detection AS (
  SELECT 
    user_id,
    start_time,
    performance,
    moving_avg_performance,
    CASE 
      WHEN ABS(moving_avg_performance - LAG(moving_avg_performance, 10) OVER (PARTITION BY user_id ORDER BY start_time)) < 0.05 
      THEN 1 ELSE 0 
    END AS is_plateau
  FROM user_performance_trend
)
SELECT 
  user_id,
  MIN(start_time) AS plateau_start,
  MAX(start_time) AS plateau_end,
  AVG(performance) AS plateau_performance
FROM (
  SELECT 
    user_id, 
    start_time, 
    performance,
    SUM(CASE WHEN is_plateau = 0 THEN 1 ELSE 0 END) OVER (PARTITION BY user_id ORDER BY start_time) AS plateau_group
  FROM plateau_detection
  WHERE is_plateau = 1
) subquery
GROUP BY user_id, plateau_group
HAVING COUNT(*) >= 10  -- Consider it a plateau if it lasts for at least 10 sessions
ORDER BY user_id, plateau_start;


User's Topic Strength and Weakness Analysis - This query provides a comprehensive view of a user's performance across all topics, ranking them from strongest to weakest.

WITH user_topic_performance AS (
  SELECT 
    ua.user_id,
    t.topic_id,
    t.topic_name,
    COUNT(ua.answer_id) AS total_answers,
    SUM(CASE WHEN ua.is_correct THEN 1 ELSE 0 END) AS correct_answers,
    AVG(ua.answer_time) AS avg_answer_time
  FROM USER_ANSWER ua
  JOIN QUESTION q ON ua.question_id = q.question_id
  JOIN TOPIC t ON q.topic_id = t.topic_id
  WHERE ua.user_id = :user_id
  GROUP BY ua.user_id, t.topic_id, t.topic_name
)
SELECT 
  topic_name,
  correct_answers::float / total_answers AS success_rate,
  avg_answer_time,
  RANK() OVER (ORDER BY correct_answers::float / total_answers DESC) AS strength_rank,
  RANK() OVER (ORDER BY correct_answers::float / total_answers ASC) AS weakness_rank
FROM user_topic_performance
ORDER BY success_rate DESC;

User's Learning Pace Over Time - This query tracks a user's learning pace over time, showing daily progress, cumulative totals, and a rolling 7-day average of questions per day.

WITH user_daily_progress AS (
  SELECT 
    DATE(start_time) AS study_date,
    SUM(total_questions) AS questions_attempted,
    SUM(correct_answers) AS questions_correct,
    AVG(end_time - start_time) AS avg_session_duration
  FROM QUIZ_SESSION
  WHERE user_id = :user_id
  GROUP BY DATE(start_time)
),
running_totals AS (
  SELECT 
    study_date,
    questions_attempted,
    questions_correct,
    avg_session_duration,
    SUM(questions_attempted) OVER (ORDER BY study_date) AS cumulative_questions,
    SUM(questions_correct) OVER (ORDER BY study_date) AS cumulative_correct
  FROM user_daily_progress
)
SELECT 
  study_date,
  questions_attempted,
  questions_correct,
  avg_session_duration,
  cumulative_questions,
  cumulative_correct,
  cumulative_correct::float / NULLIF(cumulative_questions, 0) AS cumulative_success_rate,
  (cumulative_questions - LAG(cumulative_questions, 7) OVER (ORDER BY study_date))::float / 7 AS weekly_question_rate
FROM running_totals
ORDER BY study_date;


User's Question Type Proficiency - This query breaks down the user's performance by question subtopics or types, showing overall and recent success rates, as well as timing information.

WITH user_question_performance AS (
  SELECT 
    q.subtopics,
    ua.is_correct,
    ua.answer_time,
    ROW_NUMBER() OVER (PARTITION BY q.question_id ORDER BY ua.answered_at DESC) AS recency_rank
  FROM USER_ANSWER ua
  JOIN QUESTION q ON ua.question_id = q.question_id
  WHERE ua.user_id = :user_id
)
SELECT 
  subtopics,
  COUNT(*) AS total_attempts,
  AVG(CASE WHEN is_correct THEN 1 ELSE 0 END) AS overall_success_rate,
  AVG(CASE WHEN recency_rank <= 5 AND is_correct THEN 1 WHEN recency_rank <= 5 THEN 0 ELSE NULL END) AS recent_success_rate,
  AVG(answer_time) AS avg_answer_time,
  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY answer_time) AS median_answer_time
FROM user_question_performance
GROUP BY subtopics
ORDER BY overall_success_rate DESC;

Forgetting Curve Analysis - This query estimates the parameters of each question's forgetting curve for the user, which can be used to predict when they need to review specific information.

WITH user_recall_data AS (
  SELECT 
    q.question_id,
    ua.answered_at,
    ua.is_correct,
    COALESCE(
      EXTRACT(EPOCH FROM (ua.answered_at - LAG(ua.answered_at) OVER (PARTITION BY q.question_id ORDER BY ua.answered_at)))::float / 86400,
      0
    ) AS days_since_last_review
  FROM USER_ANSWER ua
  JOIN QUESTION q ON ua.question_id = q.question_id
  WHERE ua.user_id = :user_id
),
recall_probability AS (
  SELECT 
    question_id,
    days_since_last_review,
    AVG(CASE WHEN is_correct THEN 1 ELSE 0 END) AS recall_rate,
    COUNT(*) AS review_count
  FROM user_recall_data
  GROUP BY question_id, days_since_last_review
)
SELECT 
  question_id,
  EXP(
    REGR_INTERCEPT(LN(recall_rate), days_since_last_review) +
    REGR_SLOPE(LN(recall_rate), days_since_last_review) * days_since_last_review
  ) AS predicted_recall_rate,
  REGR_R2(LN(recall_rate), days_since_last_review) AS r_squared
FROM recall_probability
GROUP BY question_id
HAVING COUNT(*) >= 5  -- Only consider questions with at least 5 review points
ORDER BY r_squared DESC, predicted_recall_rate;

Knowledge Graph Construction - This query constructs a knowledge graph for the user, showing how different topics are interconnected based on their quiz-taking patterns, along with their performance in each topic.



WITH topic_connections AS (
  SELECT 
    q1.topic_id AS topic1_id,
    q2.topic_id AS topic2_id,
    COUNT(*) AS connection_strength
  FROM USER_ANSWER ua1
  JOIN QUESTION q1 ON ua1.question_id = q1.question_id
  JOIN USER_ANSWER ua2 ON ua1.user_id = ua2.user_id AND ua1.session_id = ua2.session_id AND ua1.question_id != ua2.question_id
  JOIN QUESTION q2 ON ua2.question_id = q2.question_id
  WHERE ua1.user_id = :user_id AND q1.topic_id != q2.topic_id
  GROUP BY q1.topic_id, q2.topic_id
),
topic_performance AS (
  SELECT 
    q.topic_id,
    AVG(CASE WHEN ua.is_correct THEN 1 ELSE 0 END) AS success_rate,
    COUNT(*) AS question_count
  FROM USER_ANSWER ua
  JOIN QUESTION q ON ua.question_id = q.question_id
  WHERE ua.user_id = :user_id
  GROUP BY q.topic_id
)
SELECT 
  t1.topic_name AS topic1,
  t2.topic_name AS topic2,
  tc.connection_strength,
  tp1.success_rate AS topic1_success_rate,
  tp2.success_rate AS topic2_success_rate,
  tp1.question_count AS topic1_question_count,
  tp2.question_count AS topic2_question_count
FROM topic_connections tc
JOIN TOPIC t1 ON tc.topic1_id = t1.topic_id
JOIN TOPIC t2 ON tc.topic2_id = t2.topic_id
JOIN topic_performance tp1 ON tc.topic1_id = tp1.topic_id
JOIN topic_performance tp2 ON tc.topic2_id = tp2.topic_id
ORDER BY tc.connection_strength DESC;

Cognitive Load Analysis - This query attempts to estimate the user's cognitive load during each session based on question difficulty, answer time variability, and performance, tracking how it changes over time and correlates with success.

WITH session_metrics AS (
  SELECT 
    qs.session_id,
    qs.start_time,
    qs.end_time,
    qs.total_questions,
    qs.correct_answers,
    AVG(q.difficulty_level) AS avg_difficulty,
    AVG(ua.answer_time) AS avg_answer_time,
    STDDEV(ua.answer_time) AS stddev_answer_time
  FROM QUIZ_SESSION qs
  JOIN USER_ANSWER ua ON qs.session_id = ua.session_id
  JOIN QUESTION q ON ua.question_id = q.question_id
  WHERE qs.user_id = :user_id
  GROUP BY qs.session_id, qs.start_time, qs.end_time, qs.total_questions, qs.correct_answers
),
cognitive_load_estimate AS (
  SELECT 
    session_id,
    start_time,
    (avg_difficulty * stddev_answer_time / NULLIF(avg_answer_time, 0)) AS cognitive_load_index,
    correct_answers::float / total_questions AS success_rate,
    EXTRACT(EPOCH FROM (end_time - start_time))::float / total_questions AS time_per_question
  FROM session_metrics
)
SELECT 
  session_id,
  start_time,
  cognitive_load_index,
  success_rate,
  time_per_question,
  AVG(cognitive_load_index) OVER (ORDER BY start_time ROWS BETWEEN 4 PRECEDING AND CURRENT ROW) AS moving_avg_cognitive_load,
  CORR(cognitive_load_index, success_rate) OVER (ORDER BY start_time ROWS BETWEEN 9 PRECEDING AND CURRENT ROW) AS cognitive_load_performance_correlation
FROM cognitive_load_estimate
ORDER BY start_time;


Learning Rate and Plateau Prediction - This advanced query calculates the user's learning rate over time, predicts potential plateaus or regressions, and estimates how long it might take to reach a 95% performance level based on current learning rates.

WITH user_daily_performance AS (
  SELECT 
    DATE(start_time) AS study_date,
    AVG(correct_answers::float / total_questions) AS daily_performance,
    COUNT(*) AS sessions_count,
    SUM(total_questions) AS total_questions
  FROM QUIZ_SESSION
  WHERE user_id = :user_id
  GROUP BY DATE(start_time)
),
learning_curve AS (
  SELECT 
    study_date,
    daily_performance,
    sessions_count,
    total_questions,
    ROW_NUMBER() OVER (ORDER BY study_date) AS day_number,
    AVG(daily_performance) OVER (ORDER BY study_date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW) AS moving_avg_performance
  FROM user_daily_performance
),
learning_rate AS (
  SELECT 
    study_date,
    daily_performance,
    sessions_count,
    total_questions,
    day_number,
    moving_avg_performance,
    (moving_avg_performance - LAG(moving_avg_performance, 7) OVER (ORDER BY study_date)) / 7 AS weekly_learning_rate
  FROM learning_curve
)
SELECT 
  study_date,
  daily_performance,
  sessions_count,
  total_questions,
  moving_avg_performance,
  weekly_learning_rate,
  AVG(weekly_learning_rate) OVER (ORDER BY study_date ROWS BETWEEN 13 PRECEDING AND CURRENT ROW) AS biweekly_avg_learning_rate,
  CASE 
    WHEN weekly_learning_rate < 0.001 AND weekly_learning_rate > -0.001 THEN 'Potential Plateau'
    WHEN weekly_learning_rate < 0 THEN 'Potential Regression'
    ELSE 'Learning'
  END AS learning_status,
  CASE 
    WHEN weekly_learning_rate > 0 THEN ROUND(0.95 / NULLIF(weekly_learning_rate, 0))
    ELSE NULL
  END AS estimated_days_to_95_percent
FROM learning_rate
WHERE day_number > 7
ORDER BY study_date;

Concept Dependency Chain Analysis - This query attempts to identify potential concept dependencies by analyzing the order and timing of concept mastery, which can be used to optimize the learning path for the user.

WITH concept_performance AS (
  SELECT 
    q.subtopics,
    ua.is_correct,
    ua.answered_at,
    ROW_NUMBER() OVER (PARTITION BY q.subtopics ORDER BY ua.answered_at) AS concept_attempt_number
  FROM USER_ANSWER ua
  JOIN QUESTION q ON ua.question_id = q.question_id
  WHERE ua.user_id = :user_id
),
concept_mastery AS (
  SELECT 
    subtopics,
    MIN(CASE WHEN is_correct THEN concept_attempt_number ELSE NULL END) AS mastery_attempt,
    MIN(CASE WHEN is_correct THEN answered_at ELSE NULL END) AS mastery_date
  FROM concept_performance
  GROUP BY subtopics
),
concept_pairs AS (
  SELECT 
    cm1.subtopics AS prerequisite_concept,
    cm2.subtopics AS dependent_concept,
    cm1.mastery_date AS prerequisite_mastery_date,
    cm2.mastery_date AS dependent_mastery_date,
    cm2.mastery_attempt AS dependent_mastery_attempt
  FROM concept_mastery cm1
  JOIN concept_mastery cm2 ON cm1.mastery_date < cm2.mastery_date
)
SELECT 
  prerequisite_concept,
  dependent_concept,
  EXTRACT(DAY FROM (dependent_mastery_date - prerequisite_mastery_date)) AS days_between_mastery,
  dependent_mastery_attempt,
  COUNT(*) OVER (PARTITION BY prerequisite_concept) AS prerequisite_count,
  COUNT(*) OVER (PARTITION BY dependent_concept) AS dependent_count,
  ROW_NUMBER() OVER (PARTITION BY dependent_concept ORDER BY dependent_mastery_date - prerequisite_mastery_date) AS dependency_strength_rank
FROM concept_pairs
WHERE EXTRACT(DAY FROM (dependent_mastery_date - prerequisite_mastery_date)) BETWEEN 1 AND 30
ORDER BY prerequisite_count DESC, dependent_count DESC, days_between_mastery;


Multi-dimensional Skill Assessment - This comprehensive query provides a multi-dimensional assessment of the user's skills across different topics, considering accuracy, speed, and performance on difficult questions.

WITH skill_dimensions AS (
  SELECT 
    ua.user_id,
    q.topic_id,
    q.difficulty_level,
    ua.is_correct,
    ua.answer_time,
    CASE 
      WHEN ua.answer_time < q.avg_answer_time * 0.5 THEN 'Fast'
      WHEN ua.answer_time > q.avg_answer_time * 1.5 THEN 'Slow'
      ELSE 'Average'
    END AS speed_category
  FROM USER_ANSWER ua
  JOIN QUESTION q ON ua.question_id = q.question_id
  WHERE ua.user_id = :user_id
),
topic_proficiency AS (
  SELECT 
    topic_id,
    AVG(CASE WHEN is_correct THEN 1 ELSE 0 END) AS accuracy,
    AVG(CASE WHEN is_correct AND speed_category = 'Fast' THEN 1 ELSE 0 END) AS speed_accuracy,
    AVG(CASE WHEN difficulty_level >= 4 AND is_correct THEN 1 ELSE 0 END) AS high_difficulty_accuracy,
    COUNT(*) AS total_attempts
  FROM skill_dimensions
  GROUP BY topic_id
),
relative_strengths AS (
  SELECT 
    topic_id,
    accuracy,
    speed_accuracy,
    high_difficulty_accuracy,
    total_attempts,
    PERCENT_RANK() OVER (ORDER BY accuracy) AS accuracy_percentile,
    PERCENT_RANK() OVER (ORDER BY speed_accuracy) AS speed_accuracy_percentile,
    PERCENT_RANK() OVER (ORDER BY high_difficulty_accuracy) AS high_difficulty_accuracy_percentile
  FROM topic_proficiency
)
SELECT 
  t.topic_name,
  rs.accuracy,
  rs.speed_accuracy,
  rs.high_difficulty_accuracy,
  rs.total_attempts,
  rs.accuracy_percentile,
  rs.speed_accuracy_percentile,
  rs.high_difficulty_accuracy_percentile,
  CASE 
    WHEN rs.accuracy_percentile > 0.66 THEN 'Strong'
    WHEN rs.accuracy_percentile > 0.33 THEN 'Average'
    ELSE 'Needs Improvement'
  END AS overall_proficiency,
  CASE 
    WHEN rs.speed_accuracy_percentile > rs.accuracy_percentile THEN 'Speed'
    WHEN rs.high_difficulty_accuracy_percentile > rs.accuracy_percentile THEN 'Complex Problems'
    ELSE 'Consistent Performance'
  END AS relative_strength
FROM relative_strengths rs
JOIN TOPIC t ON rs.topic_id = t.topic_id
ORDER BY rs.accuracy_percentile DESC;


Adaptive Learning Rate Prediction with Confidence Intervals -
This advanced query provides a more nuanced view of the user's learning rate by:

Calculating learning rates at different time scales (weekly, biweekly, monthly).
Providing confidence intervals for each learning rate.
Adapting the plateau detection to consider both short-term and long-term trends.
Estimating time to mastery based on the most stable (monthly) learning rate.
Personalized Intervention Timing Predictor :

WITH user_daily_performance AS (
  SELECT 
    DATE(start_time) AS study_date,
    AVG(correct_answers::float / total_questions) AS daily_performance,
    COUNT(*) AS sessions_count,
    SUM(total_questions) AS total_questions
  FROM QUIZ_SESSION
  WHERE user_id = :user_id
  GROUP BY DATE(start_time)
),
learning_curve AS (
  SELECT 
    study_date,
    daily_performance,
    sessions_count,
    total_questions,
    ROW_NUMBER() OVER (ORDER BY study_date) AS day_number,
    AVG(daily_performance) OVER (
      ORDER BY study_date 
      ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS weekly_avg_performance,
    AVG(daily_performance) OVER (
      ORDER BY study_date 
      ROWS BETWEEN 13 PRECEDING AND CURRENT ROW
    ) AS biweekly_avg_performance,
    AVG(daily_performance) OVER (
      ORDER BY study_date 
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS monthly_avg_performance
  FROM user_daily_performance
),
learning_rates AS (
  SELECT 
    *,
    (weekly_avg_performance - LAG(weekly_avg_performance, 7) OVER (ORDER BY study_date)) / 7 AS weekly_learning_rate,
    (biweekly_avg_performance - LAG(biweekly_avg_performance, 14) OVER (ORDER BY study_date)) / 14 AS biweekly_learning_rate,
    (monthly_avg_performance - LAG(monthly_avg_performance, 30) OVER (ORDER BY study_date)) / 30 AS monthly_learning_rate
  FROM learning_curve
),
learning_rate_stats AS (
  SELECT 
    study_date,
    weekly_learning_rate,
    biweekly_learning_rate,
    monthly_learning_rate,
    AVG(weekly_learning_rate) OVER (
      ORDER BY study_date 
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS avg_weekly_learning_rate,
    STDDEV(weekly_learning_rate) OVER (
      ORDER BY study_date 
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS stddev_weekly_learning_rate,
    AVG(biweekly_learning_rate) OVER (
      ORDER BY study_date 
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS avg_biweekly_learning_rate,
    STDDEV(biweekly_learning_rate) OVER (
      ORDER BY study_date 
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS stddev_biweekly_learning_rate,
    AVG(monthly_learning_rate) OVER (
      ORDER BY study_date 
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS avg_monthly_learning_rate,
    STDDEV(monthly_learning_rate) OVER (
      ORDER BY study_date 
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ) AS stddev_monthly_learning_rate
  FROM learning_rates
  WHERE day_number > 30
)
SELECT 
  study_date,
  weekly_learning_rate,
  biweekly_learning_rate,
  monthly_learning_rate,
  avg_weekly_learning_rate,
  avg_weekly_learning_rate - (1.96 * stddev_weekly_learning_rate / SQRT(30)) AS weekly_lower_ci,
  avg_weekly_learning_rate + (1.96 * stddev_weekly_learning_rate / SQRT(30)) AS weekly_upper_ci,
  avg_biweekly_learning_rate,
  avg_biweekly_learning_rate - (1.96 * stddev_biweekly_learning_rate / SQRT(30)) AS biweekly_lower_ci,
  avg_biweekly_learning_rate + (1.96 * stddev_biweekly_learning_rate / SQRT(30)) AS biweekly_upper_ci,
  avg_monthly_learning_rate,
  avg_monthly_learning_rate - (1.96 * stddev_monthly_learning_rate / SQRT(30)) AS monthly_lower_ci,
  avg_monthly_learning_rate + (1.96 * stddev_monthly_learning_rate / SQRT(30)) AS monthly_upper_ci,
  CASE 
    WHEN avg_weekly_learning_rate < 0.001 AND avg_weekly_learning_rate > -0.001 THEN 'Potential Short-term Plateau'
    WHEN avg_monthly_learning_rate < 0.0005 AND avg_monthly_learning_rate > -0.0005 THEN 'Potential Long-term Plateau'
    WHEN avg_monthly_learning_rate < 0 THEN 'Potential Regression'
    ELSE 'Learning'
  END AS learning_status,
  CASE 
    WHEN avg_monthly_learning_rate > 0 THEN ROUND(0.95 / NULLIF(avg_monthly_learning_rate, 0))
    ELSE NULL
  END AS estimated_days_to_95_percent
FROM learning_rate_stats
ORDER BY study_date DESC
LIMIT 30;  -- Last 30 days of predictions


